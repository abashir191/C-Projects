SIC/XE Disassembler Program
Abdullahi Mohamed - 821652137
Abdullahi Mohamed - 822489428

Program starts by checking for correct inputs. (./dissem objectfile symfile). Error message thrown if the inputs aren't correct. Program then makes sure the object code file is open and then begins to parse it line by line. If the first character on the line is an 'H' then we call the method for the header record. If the first character on the line is a 'T', then we call the method for the text record. And lastly, if the first character on the line is an 'E', then we call the method for the end record.

In the header record method, we first print the starting address of the program. Then we get the name of the program which is the first 6 characters after the 'H'. Then we print the START directive and end the line. Lastly, we parse the starting and ending addresses of the program. 

In the text record method, we get the starting address for the text record we are currently on. ---(RESW)---. We also then find the length of the text record, which are the 7th and 8th index position of the text record line on the object code file. Then, we iterate until we reach the end of the text record, which we know from finding the text record length. During this iteration, we first print out the current address of the text record and prepend a certain amount of 0's in order to make the address a length of 4. We then check the symbol file and look for literals and do a function call where we check for the LTORG's that will be found throughout the program. We parse the symbol file and find the label and literal addresses and print them in the appropriate places in the assembly list file and then close the symbol table file. Next, we parse the opcode, and we begin by removing the last two bits in order to get the 6 digits needed for the opcode. The program then does another loop first checking for the different formats (format 2, 3, or 4) and prepends a '+' if the instruction is a format 4. We then do a quick format 2 check where for our program we were only required to check for the CLEAR mnemonic. We also did a special case for RSUB, where the displacement for that is just simply 0's. We then checked and printed the labels from the addresses, appending/prepending the necessary amount of 0's and also doing a method call the will check the labels for us. For format 3 instructions, we printed the addresses for the two relative addressing modes, PC or Base relative and also made sure to check for the index addressing mode where the x bit would equal 1 and did calculations with and without the x bit. After doing all of that, we then began to print the opcodes to the assembly list file. We also made sure to check for an opcode that would indicate if the 'BASE' directive would be necessary. Throughout the text record method, we had several method calls. We had a method call that would capitalize the locations/addresses for us. We had another method that checked the labels. We had another function that checked for the LTORG's. We had another method that would help remove extra/unnecessary whitespaces. We had methods for conversion that would allow us to convert from decimal to hex and another to convert from hex to decimal. We had a method specifically for format 2 instructions that would help us find the register. We had another fucntion that helped with the 'RESW' directives. And we had another method that helped us figure out the different addressing types (simple, immediate, or indirect). 

Lastly, for the end record, we find the address of the first instruction for the object program. We also print out the 'END' and 'FIRST' directives to the assembly list file. 
